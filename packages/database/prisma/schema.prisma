// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// 1. SAAS CORE MODULE
model Tenant {
  id          String   @id @default(uuid())
  name        String
  document    String   @unique // CNPJ/CPF do escritório
  planId      String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  plan        Plan?    @relation(fields: [planId], references: [id])
  users       User[]
  contacts    Contact[]
  processes   Process[]
  categories  DocumentCategory[]
  templates   DocumentTemplate[]
  communicationLogs CommunicationLog[]
  documentHistory   DocumentHistory[]
  // financialRecords  FinancialRecord[] // Deprecated/Removed
  financialSettings FinancialSettings?
  bankAccounts      BankAccount[]
  transactionCategories TransactionCategory[]
  transactions      Transaction[]
  recurringExpenses RecurringExpense[]

  relationTypes     RelationType[]
  contactRelations  ContactRelation[]
  assetTypes        AssetType[]
  contactAssets     ContactAsset[]
  contactPFs        ContactPF[]
  contactPJs        ContactPJ[]

  @@map("tenants")
}

model Plan {
  id          String   @id @default(uuid())
  name        String   // BASIC, PRO, FULL
  maxUsers    Int
  maxStorage  Int      // MB
  price       Decimal  @db.Decimal(10, 2)
  
  tenants     Tenant[]

  @@map("plans")
}

model User {
  id          String   @id @default(uuid())
  tenantId    String
  name        String
  email       String   @unique
  password    String
  role        String   // OWNER, ADMIN, MEMBER
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  tenant      Tenant   @relation(fields: [tenantId], references: [id])

  @@map("users")
}

// 2.1 ENTIDADE ÂNCORA: CONTACT (V2)
model Contact {
  id                String    @id @default(uuid())
  tenantId          String
  name              String    @map("name") // Mantendo nome original da coluna
  personType        String    @default("PF") @map("personType") // Mantendo original
  
  // Campos Legados (Mantidos para evitar perda de dados)
  cpf               String?
  rg                String?
  birthDate         DateTime?
  cnpj              String?
  companyName       String?
  stateRegistration String?

  // Campos Gerais (Denormalizados p/ performance ou legado)
  document          String?   // CPF ou CNPJ principal
  whatsapp          String?
  email             String?
  phone             String?
  notes             String?   @db.Text
  category          String?   // Cliente, Fornecedor, etc
  password          String?   // Acesso ao portal
  
  // Dados Específicos (Relacionamentos 1:1)
  pfData            ContactPF?
  pjData            ContactPJ?

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  
  // Relacionamentos
  addresses          Address[]
  additionalContacts AdditionalContact[]
  processes          Process[]
  communications     CommunicationLog[]
  relationsFrom      ContactRelation[] @relation("RelationsFrom")
  relationsTo        ContactRelation[] @relation("RelationsTo")
  assets             ContactAsset[]
  
  debtorTransactions   Transaction[] @relation("DebtorTrx")
  creditorTransactions Transaction[] @relation("CreditorTrx")
  
  recurringDebtor      RecurringExpense[] @relation("RecurringDebtor")
  recurringCreditor    RecurringExpense[] @relation("RecurringCreditor")

  tenant             Tenant   @relation(fields: [tenantId], references: [id])

  @@index([document])
  @@index([personType])
  @@index([category])
  @@map("contacts") // Revertido para manter dados
}

model ContactPF {
  id              String    @id @default(uuid())
  contactId       String    @unique
  tenantId        String
  
  // Mapping to new V2 fields
  cpf             String?   @unique
  rg              String?
  birthDate       DateTime? @map("data_nascimento")
  civilStatus     String?   @map("estado_civil") 
  profession      String?   @map("profissao")
  nationality     String?   @default("Brasileira")
  
  contact         Contact   @relation(fields: [contactId], references: [id], onDelete: Cascade)
  tenant          Tenant    @relation(fields: [tenantId], references: [id])

  @@map("contato_pf")
}

model ContactPJ {
  id              String    @id @default(uuid())
  contactId       String    @unique
  tenantId        String
  
  cnpj            String?   @unique
  companyName     String?   @map("razao_social")
  stateReg        String?   @map("inscricao_estadual")
  municipalReg    String?   @map("inscricao_municipal")
  foundingDate    DateTime? @map("data_abertura")
  legalNature     String?   @map("natureza_juridica")
  
  contact         Contact   @relation(fields: [contactId], references: [id], onDelete: Cascade)
  tenant          Tenant    @relation(fields: [tenantId], references: [id])

  @@map("contato_pj")
}

model RelationType {
  id          String   @id @default(uuid())
  tenantId    String
  name        String   // Ex: Pai, Sócio
  reverseName String?  // Ex: Filho (opcional, se null usa name)
  isBilateral Boolean  @default(false)
  createdAt   DateTime @default(now())

  relations   ContactRelation[]
  tenant      Tenant   @relation(fields: [tenantId], references: [id])
  
  @@map("relation_types")
}

model ContactRelation {
  id             String   @id @default(uuid())
  tenantId       String
  fromContactId  String
  toContactId    String
  relationTypeId String
  
  fromContact    Contact      @relation("RelationsFrom", fields: [fromContactId], references: [id], onDelete: Cascade)
  toContact      Contact      @relation("RelationsTo", fields: [toContactId], references: [id], onDelete: Cascade)
  relationType   RelationType @relation(fields: [relationTypeId], references: [id])
  
  tenant         Tenant   @relation(fields: [tenantId], references: [id])

  @@unique([fromContactId, toContactId, relationTypeId]) // Evitar duplicatas exatas
  @@map("contact_relations") // Revertido
}

model AssetType {
  id          String   @id @default(uuid())
  tenantId    String
  name        String
  createdAt   DateTime @default(now())

  assets      ContactAsset[]
  tenant      Tenant   @relation(fields: [tenantId], references: [id])
  
  @@map("asset_types")
}

model ContactAsset {
  id              String   @id @default(uuid())
  tenantId        String
  contactId       String
  assetTypeId     String
  description     String
  acquisitionDate DateTime?
  value           Decimal? @db.Decimal(10, 2)
  writeOffDate    DateTime?
  notes           String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  contact         Contact    @relation(fields: [contactId], references: [id], onDelete: Cascade)
  assetType       AssetType  @relation(fields: [assetTypeId], references: [id])
  tenant          Tenant     @relation(fields: [tenantId], references: [id])

  @@map("contact_assets")
}

model Address {
  id        String  @id @default(uuid())
  contactId String
  street    String
  number    String
  city      String
  state     String
  zipCode   String
  contact   Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)

  @@map("addresses")
}

model AdditionalContact {
  id        String  @id @default(uuid())
  contactId String
  type      String  // EMAIL, PHONE, ETC
  value     String
  contact   Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)

  @@map("additional_contacts")
}

// 2.2 MÓDULOS JURÍDICOS E FINANCEIROS
model Process {
  id             String   @id @default(uuid())
  tenantId       String
  contactId      String?
  
  // Identificadores (pelo menos um deve existir)
  cnj            String?  @unique // Para Processos Judiciais
  code           String?  @unique // Para Casos Extrajudiciais
  
  // Detalhes
  title          String?          // Nome amigável (ex: Contrato X)
  category       String?          // Natureza (Cível, Consultoria, etc)
  
  // Campos Judiciais (agora opcionais)
  court          String?   // Tribunal
  vars           String?   // Vara
  
  status         String
  value          Decimal? @db.Decimal(15, 2)
  comments       String?  // Observações rápidas
  
  recurringExpenseId String? // Link se foi gerado por recorrência
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  contact        Contact?  @relation(fields: [contactId], references: [id])
  timeline       ProcessTimeline[]
  transactions   Transaction[]
  tenant         Tenant   @relation(fields: [tenantId], references: [id])

  @@map("processes")
}

model ProcessTimeline {
  id          String   @id @default(uuid())
  processId   String
  title       String
  description String?
  date        DateTime
  type        String   // MOVEMENT, MESSAGE, FILE
  metadata    Json?    // Store file paths or message IDs here
  createdAt   DateTime @default(now())

  process     Process  @relation(fields: [processId], references: [id], onDelete: Cascade)

  @@map("process_timelines")
}

// === NOVO MÓDULO FINANCEIRO ===

model BankAccount {
  id             String   @id @default(uuid())
  tenantId       String
  name           String   // Ex: Banco do Brasil, Caixinha
  initialBalance Decimal  @db.Decimal(15, 2) @default(0)
  
  transactions   Transaction[]
  tenant         Tenant   @relation(fields: [tenantId], references: [id])

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@map("bank_accounts")
}

model RecurringExpense {
  id              String   @id @default(uuid())
  tenantId        String
  description     String
  amount          Decimal  @db.Decimal(15, 2) // Valor base
  frequency       String   // MONTHLY, WEEKLY, YEARLY
  dayOfMonth      Int      // Dia de vencimento (1-31)
  
  lastGenerated   DateTime? 
  nextProcessDate DateTime?
  isActive        Boolean   @default(true)

  categoryId      String?
  creditorId      String?
  debtorId        String?

  category        TransactionCategory? @relation(fields: [categoryId], references: [id])
  creditor        Contact?             @relation("RecurringCreditor", fields: [creditorId], references: [id])
  debtor          Contact?             @relation("RecurringDebtor", fields: [debtorId], references: [id])
  transactions    Transaction[]
  tenant          Tenant               @relation(fields: [tenantId], references: [id])

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@map("recurring_expenses")
}

model TransactionCategory {
  id          String   @id @default(uuid())
  tenantId    String
  name        String   // Ex: Água, Luz, Honorários
  type        String   // INCOME, EXPENSE
  
  transactions Transaction[]
  recurringExpenses RecurringExpense[]
  tenant       Tenant   @relation(fields: [tenantId], references: [id])
  
  @@map("transaction_categories")
}

model Transaction {
  id          String   @id @default(uuid())
  tenantId    String
  description String
  amount      Decimal  @db.Decimal(15, 2)
  type        String   // INCOME, EXPENSE
  status      String   // PENDING, PAID, CANCELLED
  dueDate     DateTime
  paymentDate DateTime?
  
  // Recorrência e Parcelamento
  recurringExpenseId String?
  installmentId      String?  // ID compartilhado entre todas as parcelas de uma compra
  installmentNumber  Int?     // 1, 2, 3...
  totalInstallments  Int?     // 10, 12...
  
  // Ajustes Financeiros
  originalAmount     Decimal? @db.Decimal(15, 2)
  interest           Decimal? @db.Decimal(15, 2) // Juros
  fine               Decimal? @db.Decimal(15, 2) // Multa
  discount           Decimal? @db.Decimal(15, 2) // Desconto
  
  bankAccountId String?
  categoryId    String?
  processId     String?
  
  // Quem envia o dinheiro (Devedor) e Quem recebe (Credor)
  debtorId      String? 
  creditorId    String? 

  bankAccount   BankAccount? @relation(fields: [bankAccountId], references: [id])
  category      TransactionCategory? @relation(fields: [categoryId], references: [id])
  process       Process? @relation(fields: [processId], references: [id])
  recurring     RecurringExpense? @relation(fields: [recurringExpenseId], references: [id])
  
  debtor        Contact? @relation("DebtorTrx", fields: [debtorId], references: [id])
  creditor      Contact? @relation("CreditorTrx", fields: [creditorId], references: [id])
  
  tenant        Tenant   @relation(fields: [tenantId], references: [id])

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@map("transactions")
}

model FinancialSettings {
   id              String @id @default(uuid())
   tenantId        String @unique
   
   // Contatos Padrão
   defaultOfficeContactId String? // ID do contato que representa o ESCRITÓRIO

   tenant          Tenant @relation(fields: [tenantId], references: [id])
   @@map("financial_settings")
}

// 3. A "INVENÇÃO DR.X": TRIAGEM E COMUNICAÇÃO
model CommunicationLog {
  id          String   @id @default(uuid())
  tenantId    String
  contactId   String?
  direction   String   // INBOUND, OUTBOUND
  channel     String   // WHATSAPP
  content     String
  mediaUrl    String?  // Caminho local do arquivo
  mediaType   String?  // AUDIO, IMAGE, PDF
  status      String   // RECEIVED, TRIAGED, ARCHIVED
  processedBy String?  // AI or AGENT
  createdAt   DateTime @default(now())

  contact     Contact? @relation(fields: [contactId], references: [id])
  tenant      Tenant   @relation(fields: [tenantId], references: [id])
  
  @@map("communication_logs")
}

// 4. MÓDULO DE MODELOS DE DOCUMENTOS (DR.X MODELS)

model DocumentCategory {
  id          String   @id @default(uuid())
  tenantId    String
  name        String
  parentId    String?
  
  parent      DocumentCategory? @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children    DocumentCategory[] @relation("CategoryHierarchy")
  tenant      Tenant   @relation(fields: [tenantId], references: [id])
  templates   DocumentTemplate[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("document_categories")
}

model DocumentTemplate {
  id          String   @id @default(uuid())
  tenantId    String
  title       String
  content     String   @db.Text
  categoryId  String?
  
  category    DocumentCategory? @relation(fields: [categoryId], references: [id])
  tenant      Tenant   @relation(fields: [tenantId], references: [id])
  history     DocumentHistory[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("document_templates")
}

model DocumentHistory {
  id          String   @id @default(uuid())
  tenantId    String
  templateId  String?
  title       String
  content     String   @db.Text
  snapshot    Json?    // Stores the variables values at time of creation
  status      String   // DRAFT, FINALIZED
  
  template    DocumentTemplate? @relation(fields: [templateId], references: [id])
  tenant      Tenant   @relation(fields: [tenantId], references: [id])
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("document_history")
}

model DocumentSettings {
  id          String   @id @default(uuid())
  key         String   @unique // HEADER, FOOTER, FONT_FAMILY
  value       String?
  
  updatedAt   DateTime @updatedAt

  @@map("document_settings")
}
